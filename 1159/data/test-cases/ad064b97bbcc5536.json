{"uid":"ad064b97bbcc5536","name":"test_workflow_failure_types_configured","fullName":"tests.worker.test_workflow#test_workflow_failure_types_configured","historyId":"54a164cbb5e31743543b78c8b80b6d07","time":{"start":1724118983032,"stop":1724119005041,"duration":22009},"status":"failed","statusMessage":"AssertionError: timed out waiting for equal, asserted against last value of False","statusTrace":"client = <temporalio.client.Client object at 0xff43a0505490>\nenv = <temporalio.testing._workflow._EphemeralServerWorkflowEnvironment object at 0xff43a0505400>\n\n    async def test_workflow_failure_types_configured(\n        client: Client, env: WorkflowEnvironment\n    ):\n        if env.supports_time_skipping:\n            pytest.skip(\n                \"Java test server: https://github.com/temporalio/sdk-java/issues/1903\"\n            )\n    \n        # Asserter for a single scenario\n        async def assert_scenario(\n            workflow: Type[FailureTypesWorkflowBase],\n            *,\n            expect_task_fail: bool,\n            fail_message_contains: str,\n            worker_level_failure_exception_type: Optional[Type[Exception]] = None,\n            workflow_scenario: Optional[FailureTypesScenario] = None,\n            signal_scenario: Optional[FailureTypesScenario] = None,\n            update_scenario: Optional[FailureTypesScenario] = None,\n        ) -> None:\n            logging.debug(\n                f\"Asserting scenario %s\",\n                {\n                    \"workflow\": workflow,\n                    \"expect_task_fail\": expect_task_fail,\n                    \"fail_message_contains\": fail_message_contains,\n                    \"worker_level_failure_exception_type\": worker_level_failure_exception_type,\n                    \"workflow_scenario\": workflow_scenario,\n                    \"signal_scenario\": signal_scenario,\n                    \"update_scenario\": update_scenario,\n                },\n            )\n            async with new_worker(\n                client,\n                workflow,\n                max_cached_workflows=0,\n                workflow_failure_exception_types=[worker_level_failure_exception_type]\n                if worker_level_failure_exception_type\n                else [],\n            ) as worker:\n                # Start workflow\n                handle = await client.start_workflow(\n                    workflow.run,\n                    workflow_scenario or FailureTypesScenario.WAIT_FOREVER,\n                    id=f\"wf-{uuid.uuid4()}\",\n                    task_queue=worker.task_queue,\n                )\n                if signal_scenario:\n                    await handle.signal(workflow.signal, signal_scenario)\n                update_handle: Optional[WorkflowUpdateHandle[Any]] = None\n                if update_scenario:\n                    update_handle = await handle.start_update(\n                        workflow.update,\n                        update_scenario,\n                        wait_for_stage=WorkflowUpdateStage.ACCEPTED,\n                        id=\"my-update-1\",\n                    )\n    \n                # Expect task or exception fail\n                if expect_task_fail:\n    \n                    async def has_expected_task_fail() -> bool:\n                        async for e in handle.fetch_history_events():\n                            if (\n                                e.HasField(\"workflow_task_failed_event_attributes\")\n                                and fail_message_contains\n                                in e.workflow_task_failed_event_attributes.failure.message\n                            ):\n                                return True\n                        return False\n    \n                    await assert_eq_eventually(\n                        True, has_expected_task_fail, timeout=timedelta(seconds=20)\n                    )\n                else:\n                    with pytest.raises(TemporalError) as err:\n                        # Update does not throw on non-determinism, the workflow\n                        # does instead\n                        if (\n                            update_handle\n                            and update_scenario\n                            == FailureTypesScenario.THROW_CUSTOM_EXCEPTION\n                        ):\n                            await update_handle.result()\n                        else:\n                            await handle.result()\n                    assert isinstance(err.value.cause, ApplicationError)\n                    assert fail_message_contains in err.value.cause.message\n    \n        # Run a scenario\n        async def run_scenario(\n            workflow: Type[FailureTypesWorkflowBase],\n            scenario: FailureTypesScenario,\n            *,\n            expect_task_fail: bool = False,\n            worker_level_failure_exception_type: Optional[Type[Exception]] = None,\n        ) -> None:\n            # Run for workflow, signal, and update\n            fail_message_contains = (\n                \"Intentional exception\"\n                if scenario == FailureTypesScenario.THROW_CUSTOM_EXCEPTION\n                else \"Nondeterminism\"\n            )\n            await assert_scenario(\n                workflow,\n                expect_task_fail=expect_task_fail,\n                fail_message_contains=fail_message_contains,\n                worker_level_failure_exception_type=worker_level_failure_exception_type,\n                workflow_scenario=scenario,\n            )\n            await assert_scenario(\n                workflow,\n                expect_task_fail=expect_task_fail,\n                fail_message_contains=fail_message_contains,\n                worker_level_failure_exception_type=worker_level_failure_exception_type,\n                signal_scenario=scenario,\n            )\n            await assert_scenario(\n                workflow,\n                expect_task_fail=expect_task_fail,\n                fail_message_contains=fail_message_contains,\n                worker_level_failure_exception_type=worker_level_failure_exception_type,\n                update_scenario=scenario,\n            )\n    \n        # Run all tasks concurrently\n>       await asyncio.gather(\n            # When unconfigured completely, confirm task fails as normal\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n                expect_task_fail=True,\n            ),\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n                expect_task_fail=True,\n            ),\n            # When configured at the worker level explicitly, confirm not task fail\n            # but rather expected exceptions\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n                worker_level_failure_exception_type=FailureTypesCustomException,\n            ),\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n                worker_level_failure_exception_type=workflow.NondeterminismError,\n            ),\n            # When configured at the worker level inherited\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n                worker_level_failure_exception_type=Exception,\n            ),\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n                worker_level_failure_exception_type=Exception,\n            ),\n            # When configured at the workflow level explicitly\n            run_scenario(\n                FailureTypesConfiguredExplicitlyWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n            ),\n            run_scenario(\n                FailureTypesConfiguredExplicitlyWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n            ),\n            # When configured at the workflow level inherited\n            run_scenario(\n                FailureTypesConfiguredInheritedWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n            ),\n            run_scenario(\n                FailureTypesConfiguredInheritedWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n            ),\n        )\n\ntests/worker/test_workflow.py:4932: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/worker/test_workflow.py:4909: in run_scenario\n    await assert_scenario(\ntests/worker/test_workflow.py:4877: in assert_scenario\n    await assert_eq_eventually(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nexpected = True\nfn = <function test_workflow_failure_types_configured.<locals>.assert_scenario.<locals>.has_expected_task_fail at 0xff439594c220>\n\n    async def assert_eq_eventually(\n        expected: T,\n        fn: Callable[[], Awaitable[T]],\n        *,\n        timeout: timedelta = timedelta(seconds=10),\n        interval: timedelta = timedelta(milliseconds=200),\n    ) -> None:\n        start_sec = time.monotonic()\n        last_value = None\n        while timedelta(seconds=time.monotonic() - start_sec) < timeout:\n            last_value = await fn()\n            if expected == last_value:\n                return\n            await asyncio.sleep(interval.total_seconds())\n        assert (\n>           expected == last_value\n        ), f\"timed out waiting for equal, asserted against last value of {last_value}\"\nE       AssertionError: timed out waiting for equal, asserted against last value of False\n\ntests/helpers/__init__.py:64: AssertionError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":0,"retriesStatusChange":false,"beforeStages":[{"name":"event_loop","time":{"start":1724118821998,"stop":1724118821999,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"env_type","time":{"start":1724118821999,"stop":1724118822000,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"env","time":{"start":1724118822000,"stop":1724118825487,"duration":3487},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"client","time":{"start":1724118983032,"stop":1724118983032,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"status":"failed","statusMessage":"AssertionError: timed out waiting for equal, asserted against last value of False","statusTrace":"client = <temporalio.client.Client object at 0xff43a0505490>\nenv = <temporalio.testing._workflow._EphemeralServerWorkflowEnvironment object at 0xff43a0505400>\n\n    async def test_workflow_failure_types_configured(\n        client: Client, env: WorkflowEnvironment\n    ):\n        if env.supports_time_skipping:\n            pytest.skip(\n                \"Java test server: https://github.com/temporalio/sdk-java/issues/1903\"\n            )\n    \n        # Asserter for a single scenario\n        async def assert_scenario(\n            workflow: Type[FailureTypesWorkflowBase],\n            *,\n            expect_task_fail: bool,\n            fail_message_contains: str,\n            worker_level_failure_exception_type: Optional[Type[Exception]] = None,\n            workflow_scenario: Optional[FailureTypesScenario] = None,\n            signal_scenario: Optional[FailureTypesScenario] = None,\n            update_scenario: Optional[FailureTypesScenario] = None,\n        ) -> None:\n            logging.debug(\n                f\"Asserting scenario %s\",\n                {\n                    \"workflow\": workflow,\n                    \"expect_task_fail\": expect_task_fail,\n                    \"fail_message_contains\": fail_message_contains,\n                    \"worker_level_failure_exception_type\": worker_level_failure_exception_type,\n                    \"workflow_scenario\": workflow_scenario,\n                    \"signal_scenario\": signal_scenario,\n                    \"update_scenario\": update_scenario,\n                },\n            )\n            async with new_worker(\n                client,\n                workflow,\n                max_cached_workflows=0,\n                workflow_failure_exception_types=[worker_level_failure_exception_type]\n                if worker_level_failure_exception_type\n                else [],\n            ) as worker:\n                # Start workflow\n                handle = await client.start_workflow(\n                    workflow.run,\n                    workflow_scenario or FailureTypesScenario.WAIT_FOREVER,\n                    id=f\"wf-{uuid.uuid4()}\",\n                    task_queue=worker.task_queue,\n                )\n                if signal_scenario:\n                    await handle.signal(workflow.signal, signal_scenario)\n                update_handle: Optional[WorkflowUpdateHandle[Any]] = None\n                if update_scenario:\n                    update_handle = await handle.start_update(\n                        workflow.update,\n                        update_scenario,\n                        wait_for_stage=WorkflowUpdateStage.ACCEPTED,\n                        id=\"my-update-1\",\n                    )\n    \n                # Expect task or exception fail\n                if expect_task_fail:\n    \n                    async def has_expected_task_fail() -> bool:\n                        async for e in handle.fetch_history_events():\n                            if (\n                                e.HasField(\"workflow_task_failed_event_attributes\")\n                                and fail_message_contains\n                                in e.workflow_task_failed_event_attributes.failure.message\n                            ):\n                                return True\n                        return False\n    \n                    await assert_eq_eventually(\n                        True, has_expected_task_fail, timeout=timedelta(seconds=20)\n                    )\n                else:\n                    with pytest.raises(TemporalError) as err:\n                        # Update does not throw on non-determinism, the workflow\n                        # does instead\n                        if (\n                            update_handle\n                            and update_scenario\n                            == FailureTypesScenario.THROW_CUSTOM_EXCEPTION\n                        ):\n                            await update_handle.result()\n                        else:\n                            await handle.result()\n                    assert isinstance(err.value.cause, ApplicationError)\n                    assert fail_message_contains in err.value.cause.message\n    \n        # Run a scenario\n        async def run_scenario(\n            workflow: Type[FailureTypesWorkflowBase],\n            scenario: FailureTypesScenario,\n            *,\n            expect_task_fail: bool = False,\n            worker_level_failure_exception_type: Optional[Type[Exception]] = None,\n        ) -> None:\n            # Run for workflow, signal, and update\n            fail_message_contains = (\n                \"Intentional exception\"\n                if scenario == FailureTypesScenario.THROW_CUSTOM_EXCEPTION\n                else \"Nondeterminism\"\n            )\n            await assert_scenario(\n                workflow,\n                expect_task_fail=expect_task_fail,\n                fail_message_contains=fail_message_contains,\n                worker_level_failure_exception_type=worker_level_failure_exception_type,\n                workflow_scenario=scenario,\n            )\n            await assert_scenario(\n                workflow,\n                expect_task_fail=expect_task_fail,\n                fail_message_contains=fail_message_contains,\n                worker_level_failure_exception_type=worker_level_failure_exception_type,\n                signal_scenario=scenario,\n            )\n            await assert_scenario(\n                workflow,\n                expect_task_fail=expect_task_fail,\n                fail_message_contains=fail_message_contains,\n                worker_level_failure_exception_type=worker_level_failure_exception_type,\n                update_scenario=scenario,\n            )\n    \n        # Run all tasks concurrently\n>       await asyncio.gather(\n            # When unconfigured completely, confirm task fails as normal\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n                expect_task_fail=True,\n            ),\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n                expect_task_fail=True,\n            ),\n            # When configured at the worker level explicitly, confirm not task fail\n            # but rather expected exceptions\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n                worker_level_failure_exception_type=FailureTypesCustomException,\n            ),\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n                worker_level_failure_exception_type=workflow.NondeterminismError,\n            ),\n            # When configured at the worker level inherited\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n                worker_level_failure_exception_type=Exception,\n            ),\n            run_scenario(\n                FailureTypesUnconfiguredWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n                worker_level_failure_exception_type=Exception,\n            ),\n            # When configured at the workflow level explicitly\n            run_scenario(\n                FailureTypesConfiguredExplicitlyWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n            ),\n            run_scenario(\n                FailureTypesConfiguredExplicitlyWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n            ),\n            # When configured at the workflow level inherited\n            run_scenario(\n                FailureTypesConfiguredInheritedWorkflow,\n                FailureTypesScenario.THROW_CUSTOM_EXCEPTION,\n            ),\n            run_scenario(\n                FailureTypesConfiguredInheritedWorkflow,\n                FailureTypesScenario.CAUSE_NON_DETERMINISM,\n            ),\n        )\n\ntests/worker/test_workflow.py:4932: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/worker/test_workflow.py:4909: in run_scenario\n    await assert_scenario(\ntests/worker/test_workflow.py:4877: in assert_scenario\n    await assert_eq_eventually(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nexpected = True\nfn = <function test_workflow_failure_types_configured.<locals>.assert_scenario.<locals>.has_expected_task_fail at 0xff439594c220>\n\n    async def assert_eq_eventually(\n        expected: T,\n        fn: Callable[[], Awaitable[T]],\n        *,\n        timeout: timedelta = timedelta(seconds=10),\n        interval: timedelta = timedelta(milliseconds=200),\n    ) -> None:\n        start_sec = time.monotonic()\n        last_value = None\n        while timedelta(seconds=time.monotonic() - start_sec) < timeout:\n            last_value = await fn()\n            if expected == last_value:\n                return\n            await asyncio.sleep(interval.total_seconds())\n        assert (\n>           expected == last_value\n        ), f\"timed out waiting for equal, asserted against last value of {last_value}\"\nE       AssertionError: timed out waiting for equal, asserted against last value of False\n\ntests/helpers/__init__.py:64: AssertionError","steps":[],"attachments":[{"uid":"1b909f788b9fe2b5","name":"log","source":"1b909f788b9fe2b5.txt","type":"text/plain","size":54667}],"parameters":[],"shouldDisplayMessage":true,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[{"name":"env::finalizer","time":{"start":1724119087417,"stop":1724119087441,"duration":24},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"event_loop::2","time":{"start":1724119087452,"stop":1724119087452,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"event_loop::_close_event_loop","time":{"start":1724119087453,"stop":1724119087453,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"event_loop::_provide_clean_event_loop","time":{"start":1724119087453,"stop":1724119087453,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"tag","value":"asyncio"},{"name":"parentSuite","value":"tests.worker"},{"name":"suite","value":"test_workflow"},{"name":"host","value":"runner"},{"name":"thread","value":"5182-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.worker.test_workflow"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[],"categories":[{"name":"Product defects","matchedStatuses":[],"flaky":false}],"tags":["asyncio"]},"source":"ad064b97bbcc5536.json","parameterValues":[]}
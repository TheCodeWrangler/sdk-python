{"uid":"2ea048a0ac3c1db3","name":"test_replayer_command_reordering_backward_compatibility","fullName":"tests.worker.test_replayer#test_replayer_command_reordering_backward_compatibility","historyId":"0d9cb618d96c0556279ba93f5aee3abf","time":{"start":1724118980427,"stop":1724118980732,"duration":305},"description":"\n    The UpdateCompletionAfterWorkflowReturn workflow above features an update handler that returns\n    after the main workflow coroutine has exited. It will (if an update is sent in the first WFT)\n    generate a raw command sequence (before sending to core) of\n\n    [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted].\n\n    Prior to https://github.com/temporalio/sdk-python/pull/569, Python truncated this command\n    sequence to\n\n    [UpdateAccepted, CompleteWorkflowExecution].\n\n    With #569, Python performs no truncation, and Core changes it to\n\n    [UpdateAccepted, UpdateCompleted, CompleteWorkflowExecution].\n\n    This test takes a history generated using pre-#569 SDK code, and replays it. This succeeds.\n    The history is\n\n    1 WorkflowExecutionStarted\n    2 WorkflowTaskScheduled\n    3 WorkflowTaskStarted\n    4 WorkflowTaskCompleted\n    5 WorkflowExecutionUpdateAccepted\n    6 WorkflowExecutionCompleted\n\n    Note that the history lacks a WorkflowExecutionUpdateCompleted event.\n\n    If Core's logic (which involves a flag) incorrectly allowed this history to be replayed\n    using Core's post-#569 implementation, then a non-determinism error would result. Specifically,\n    Core would, at some point during replay, do the following:\n\n    Receive [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted] from lang,\n    change that to [UpdateAccepted, UpdateCompleted, CompleteWorkflowExecution]\n    and create an UpdateMachine instance (the WorkflowTaskMachine instance already exists).\n    Then continue to consume history events.\n\n    Event 5 WorkflowExecutionUpdateAccepted would apply to the UpdateMachine associated with\n    the UpdateAccepted command, but event 6 WorkflowExecutionCompleted would not, since\n    core is expecting an event that can be applied to the UpdateMachine corresponding to\n    UpdateCompleted. If we modify core to incorrectly apply its new logic then we do see that:\n\n    [TMPRL1100] Nondeterminism error: Update machine does not handle this event: HistoryEvent(id: 6, WorkflowExecutionCompleted)\n\n    The test passes because core in fact (because the history lacks the flag) uses its old logic\n    and changes the command sequence from [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted]\n    to [UpdateAccepted, CompleteWorkflowExecution], and events 5 and 6 can be applied to the\n    corresponding state machines.\n    ","descriptionHtml":"<pre><code>The UpdateCompletionAfterWorkflowReturn workflow above features an update handler that returns\nafter the main workflow coroutine has exited. It will (if an update is sent in the first WFT)\ngenerate a raw command sequence (before sending to core) of\n\n[UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted].\n\nPrior to https://github.com/temporalio/sdk-python/pull/569, Python truncated this command\nsequence to\n\n[UpdateAccepted, CompleteWorkflowExecution].\n\nWith #569, Python performs no truncation, and Core changes it to\n\n[UpdateAccepted, UpdateCompleted, CompleteWorkflowExecution].\n\nThis test takes a history generated using pre-#569 SDK code, and replays it. This succeeds.\nThe history is\n\n1 WorkflowExecutionStarted\n2 WorkflowTaskScheduled\n3 WorkflowTaskStarted\n4 WorkflowTaskCompleted\n5 WorkflowExecutionUpdateAccepted\n6 WorkflowExecutionCompleted\n\nNote that the history lacks a WorkflowExecutionUpdateCompleted event.\n\nIf Core's logic (which involves a flag) incorrectly allowed this history to be replayed\nusing Core's post-#569 implementation, then a non-determinism error would result. Specifically,\nCore would, at some point during replay, do the following:\n\nReceive [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted] from lang,\nchange that to [UpdateAccepted, UpdateCompleted, CompleteWorkflowExecution]\nand create an UpdateMachine instance (the WorkflowTaskMachine instance already exists).\nThen continue to consume history events.\n\nEvent 5 WorkflowExecutionUpdateAccepted would apply to the UpdateMachine associated with\nthe UpdateAccepted command, but event 6 WorkflowExecutionCompleted would not, since\ncore is expecting an event that can be applied to the UpdateMachine corresponding to\nUpdateCompleted. If we modify core to incorrectly apply its new logic then we do see that:\n\n[TMPRL1100] Nondeterminism error: Update machine does not handle this event: HistoryEvent(id: 6, WorkflowExecutionCompleted)\n\nThe test passes because core in fact (because the history lacks the flag) uses its old logic\nand changes the command sequence from [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted]\nto [UpdateAccepted, CompleteWorkflowExecution], and events 5 and 6 can be applied to the\ncorresponding state machines.\n</code></pre>\n","status":"passed","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":1,"retriesStatusChange":false,"beforeStages":[{"name":"event_loop","time":{"start":1724118948049,"stop":1724118948050,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"testStage":{"description":"\n    The UpdateCompletionAfterWorkflowReturn workflow above features an update handler that returns\n    after the main workflow coroutine has exited. It will (if an update is sent in the first WFT)\n    generate a raw command sequence (before sending to core) of\n\n    [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted].\n\n    Prior to https://github.com/temporalio/sdk-python/pull/569, Python truncated this command\n    sequence to\n\n    [UpdateAccepted, CompleteWorkflowExecution].\n\n    With #569, Python performs no truncation, and Core changes it to\n\n    [UpdateAccepted, UpdateCompleted, CompleteWorkflowExecution].\n\n    This test takes a history generated using pre-#569 SDK code, and replays it. This succeeds.\n    The history is\n\n    1 WorkflowExecutionStarted\n    2 WorkflowTaskScheduled\n    3 WorkflowTaskStarted\n    4 WorkflowTaskCompleted\n    5 WorkflowExecutionUpdateAccepted\n    6 WorkflowExecutionCompleted\n\n    Note that the history lacks a WorkflowExecutionUpdateCompleted event.\n\n    If Core's logic (which involves a flag) incorrectly allowed this history to be replayed\n    using Core's post-#569 implementation, then a non-determinism error would result. Specifically,\n    Core would, at some point during replay, do the following:\n\n    Receive [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted] from lang,\n    change that to [UpdateAccepted, UpdateCompleted, CompleteWorkflowExecution]\n    and create an UpdateMachine instance (the WorkflowTaskMachine instance already exists).\n    Then continue to consume history events.\n\n    Event 5 WorkflowExecutionUpdateAccepted would apply to the UpdateMachine associated with\n    the UpdateAccepted command, but event 6 WorkflowExecutionCompleted would not, since\n    core is expecting an event that can be applied to the UpdateMachine corresponding to\n    UpdateCompleted. If we modify core to incorrectly apply its new logic then we do see that:\n\n    [TMPRL1100] Nondeterminism error: Update machine does not handle this event: HistoryEvent(id: 6, WorkflowExecutionCompleted)\n\n    The test passes because core in fact (because the history lacks the flag) uses its old logic\n    and changes the command sequence from [UpdateAccepted, CompleteWorkflowExecution, UpdateCompleted]\n    to [UpdateAccepted, CompleteWorkflowExecution], and events 5 and 6 can be applied to the\n    corresponding state machines.\n    ","status":"passed","steps":[],"attachments":[{"uid":"a151ba7894c92d0f","name":"log","source":"a151ba7894c92d0f.txt","type":"text/plain","size":166}],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":1,"hasContent":true,"attachmentStep":false},"afterStages":[{"name":"event_loop::2","time":{"start":1724119091496,"stop":1724119091497,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"event_loop::_close_event_loop","time":{"start":1724119091497,"stop":1724119091497,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"event_loop::_provide_clean_event_loop","time":{"start":1724119091497,"stop":1724119091497,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"tag","value":"asyncio"},{"name":"parentSuite","value":"tests.worker"},{"name":"suite","value":"test_replayer"},{"name":"host","value":"fv-az1345-791"},{"name":"thread","value":"4616-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.worker.test_replayer"},{"name":"resultFormat","value":"allure2"}],"parameters":[],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[{"uid":"a44ea1fc17d28adf","status":"passed","time":{"start":1724118745674,"stop":1724118745857,"duration":183}}],"categories":[],"history":{"statistic":{"failed":0,"broken":0,"skipped":0,"passed":2,"unknown":0,"total":2},"items":[{"uid":"ecd5b2f405d9727e","reportUrl":"https://temporalio.github.io/sdk-python/1159//#testresult/ecd5b2f405d9727e","status":"passed","time":{"start":1724118883812,"stop":1724118884020,"duration":208}}]},"tags":["asyncio"]},"source":"2ea048a0ac3c1db3.json","parameterValues":[]}